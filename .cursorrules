# Chat-Turbo Monorepo - Production-Ready Architecture Rules

This is a **production-ready, open-source chat application** built with modern technologies. All code must maintain enterprise-grade quality, clean architecture, and scalability.

---

## ğŸ—ï¸ **MONOREPO ARCHITECTURE**

### **Apps Structure**
- `apps/web/` â†’ Next.js 16+ frontend with App Router
- `apps/api/` â†’ Express.js + Socket.IO backend with TypeScript
- `apps/docs/` â†’ Documentation site (optional)

### **Packages Structure**
- `packages/shared/` â†’ Shared types, validations, constants
- `packages/ui/` â†’ Reusable UI component library
- `packages/eslint-config/` â†’ Shared ESLint configurations
- `packages/typescript-config/` â†’ Shared TypeScript configurations

---

## ğŸ¯ **CORE ENGINEERING PRINCIPLES**

1. **Senior-Level Code Quality**: Always write code as a senior software engineer
2. **TypeScript First**: 100% TypeScript, no `any` types unless absolutely necessary
3. **Clean Architecture**: Separation of concerns, SOLID principles
4. **Composition over Inheritance**: Prefer functional composition
5. **Performance by Design**: Optimize for scalability and performance
6. **Security First**: Implement security best practices from the start

---

## ğŸ“ **FRONTEND ARCHITECTURE (`apps/web/`)**

### **Required Folder Structure**
```
apps/web/
â”œâ”€â”€ app/                    # Next.js App Router pages
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                 # Base UI components (Button, Input, etc.)
â”‚   â”œâ”€â”€ features/           # Feature-specific components
â”‚   â”œâ”€â”€ chat/               # Chat-related components
â”‚   â”œâ”€â”€ auth/               # Authentication components
â”‚   â””â”€â”€ layouts/            # Layout components
â”œâ”€â”€ hooks/                  # Custom React hooks
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api/                # API client functions
â”‚   â”œâ”€â”€ stores/             # State management (Zustand/Redux)
â”‚   â”œâ”€â”€ constants/          # Application constants
â”‚   â””â”€â”€ utils.ts            # Utility functions
â”œâ”€â”€ types/                  # Frontend-specific types
â”œâ”€â”€ assets/                 # Static assets (images, icons)
â””â”€â”€ config/                 # Configuration files
```

### **Component Architecture Rules**
- **Pure Components**: All components must be pure and predictable
- **Single Responsibility**: One component = one responsibility
- **Composition Pattern**: Break large components into smaller, composable parts
- **Props Interface**: Always define TypeScript interfaces for props
- **Named Exports**: Use named exports, avoid default exports for components

### **State Management**
- Use **Zustand** for global state (lightweight, TypeScript-friendly)
- Use **React Query/TanStack Query** for server state
- Keep local state minimal with `useState`
- Implement proper error boundaries

### **Performance Rules**
- Use `React.memo()` for expensive components
- Implement proper `useMemo()` and `useCallback()` for optimization
- Lazy load components with `React.lazy()`
- Optimize images with Next.js Image component

---

## ğŸ”§ **BACKEND ARCHITECTURE (`apps/api/`)**

### **Required Folder Structure**
```
apps/api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/        # Route controllers
â”‚   â”œâ”€â”€ services/           # Business logic layer
â”‚   â”œâ”€â”€ models/             # Database models (Drizzle ORM)
â”‚   â”œâ”€â”€ middleware/         # Express middleware
â”‚   â”œâ”€â”€ routes/             # API route definitions
â”‚   â”œâ”€â”€ socket/             # Socket.IO event handlers
â”‚   â”œâ”€â”€ utils/              # Backend utilities
â”‚   â”œâ”€â”€ types/              # Backend-specific types
â”‚   â”œâ”€â”€ config/             # Configuration (DB, JWT, etc.)
â”‚   â””â”€â”€ server.ts           # Main server file
â”œâ”€â”€ drizzle/                # Database migrations and schemas
â””â”€â”€ tests/                  # Backend tests
```

### **API Design Rules**
- **RESTful Design**: Follow REST conventions
- **Input Validation**: Use Zod for all input validation
- **Error Handling**: Consistent error responses with proper HTTP codes
- **Authentication**: JWT-based auth with refresh tokens
- **Rate Limiting**: Implement rate limiting for all endpoints
- **CORS**: Proper CORS configuration

### **Database Rules**
- **Drizzle ORM**: Use Drizzle for type-safe database operations
- **Migrations**: All schema changes through migrations
- **Indexing**: Proper database indexing for performance
- **Transactions**: Use transactions for multi-step operations

---

## ğŸ“¦ **SHARED PACKAGES RULES**

### **`packages/shared/`**
- **Types**: All shared TypeScript interfaces and types
- **Validations**: Zod schemas for API contracts
- **Constants**: Shared constants across frontend and backend
- **Utilities**: Pure utility functions used by multiple apps

### **`packages/ui/`**
- **Design System**: Consistent design tokens and components
- **Accessibility**: WCAG 2.1 AA compliance
- **Documentation**: Storybook for component documentation
- **Testing**: Unit tests for all components

---

## ğŸ¨ **STYLING & DESIGN RULES**

### **TailwindCSS Standards**
- Use **design tokens** for colors, spacing, typography
- Create **component variants** using `cva` (class-variance-authority)
- **Responsive Design**: Mobile-first approach
- **Dark Mode**: Support for dark/light theme switching
- **Consistent Spacing**: Use Tailwind spacing scale consistently

---

## ğŸ”’ **SECURITY REQUIREMENTS**

### **Frontend Security**
- **Input Sanitization**: Sanitize all user inputs
- **XSS Protection**: Prevent cross-site scripting
- **CSRF Protection**: Implement CSRF tokens
- **Secure Storage**: Use secure storage for sensitive data

### **Backend Security**
- **Authentication**: JWT with proper expiration
- **Authorization**: Role-based access control (RBAC)
- **Input Validation**: Server-side validation for all inputs
- **SQL Injection**: Use parameterized queries (Drizzle handles this)
- **Rate Limiting**: Prevent abuse with rate limiting

---

## ğŸ§ª **TESTING REQUIREMENTS**

### **Frontend Testing**
- **Unit Tests**: Jest + React Testing Library
- **Integration Tests**: Test user workflows
- **E2E Tests**: Playwright for critical paths
- **Component Tests**: Storybook interaction tests

### **Backend Testing**
- **Unit Tests**: Jest for business logic
- **Integration Tests**: Test API endpoints
- **Database Tests**: Test database operations
- **Socket Tests**: Test real-time functionality

---

## ğŸ“Š **PERFORMANCE STANDARDS**

### **Frontend Performance**
- **Core Web Vitals**: Meet Google's CWV standards
- **Bundle Size**: Keep JavaScript bundles under 250KB
- **Image Optimization**: Use Next.js Image with proper formats
- **Code Splitting**: Implement route-based code splitting

### **Backend Performance**
- **Response Time**: API responses under 200ms
- **Database Queries**: Optimize with proper indexing
- **Caching**: Implement Redis for frequently accessed data
- **Connection Pooling**: Use connection pooling for database

---

## ğŸš€ **DEPLOYMENT & DEVOPS**

### **Environment Configuration**
- **Environment Variables**: Use `.env` files properly
- **Configuration Validation**: Validate all config at startup
- **Secrets Management**: Never commit secrets to version control

### **CI/CD Pipeline**
- **Automated Testing**: All tests must pass before merge
- **Type Checking**: TypeScript compilation must succeed
- **Linting**: ESLint and Prettier checks
- **Build Verification**: Successful build required

---

## ğŸ“ **CODE QUALITY STANDARDS**

### **TypeScript Rules**
```typescript
// âœ… Good: Proper interface definition
interface ChatMessage {
  id: string;
  content: string;
  senderId: string;
  chatId: string;
  createdAt: Date;
  updatedAt: Date;
}

// âœ… Good: Proper error handling
const sendMessage = async (message: ChatMessage): Promise<Result<ChatMessage, Error>> => {
  try {
    const result = await api.post('/messages', message);
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error as Error };
  }
};
```

### **React Component Standards**
```typescript
// âœ… Good: Proper component structure
interface MessageBubbleProps {
  message: ChatMessage;
  isOwn: boolean;
  onDelete?: (messageId: string) => void;
}

export const MessageBubble = ({ message, isOwn, onDelete }: MessageBubbleProps) => {
  const handleDelete = useCallback(() => {
    onDelete?.(message.id);
  }, [message.id, onDelete]);

  return (
    <div className={cn("flex", isOwn ? "justify-end" : "justify-start")}>
      {/* Component JSX */}
    </div>
  );
};
```

---

## ğŸ”„ **REAL-TIME FEATURES**

### **Socket.IO Implementation**
- **Event Typing**: Type all socket events
- **Error Handling**: Proper error handling for socket events
- **Reconnection**: Handle connection drops gracefully
- **Room Management**: Efficient room joining/leaving

---

## ğŸ“š **DOCUMENTATION REQUIREMENTS**

### **Code Documentation**
- **JSDoc Comments**: For all public APIs
- **README Files**: Comprehensive setup and usage instructions
- **API Documentation**: OpenAPI/Swagger for backend APIs
- **Component Documentation**: Storybook for UI components

### **Architecture Documentation**
- **System Architecture**: High-level system design
- **Database Schema**: ERD and table documentation
- **API Contracts**: Request/response schemas
- **Deployment Guide**: Step-by-step deployment instructions

---

## ğŸ¯ **IMMEDIATE REFACTORING PRIORITIES**

1. **Extract Mock Data**: Move mock data to separate service layer
2. **Implement Proper Types**: Create comprehensive type definitions
3. **Add Error Boundaries**: Implement React error boundaries
4. **State Management**: Replace useState with proper state management
5. **API Integration**: Replace mock functions with real API calls
6. **Testing Setup**: Add comprehensive test suites
7. **Performance Optimization**: Implement React.memo and proper memoization
8. **Accessibility**: Add proper ARIA labels and keyboard navigation

---

## âš¡ **DEVELOPMENT WORKFLOW**

### **Before Starting Any Feature**
1. Define TypeScript interfaces first
2. Create API contracts (if backend changes needed)
3. Write tests (TDD approach)
4. Implement feature with proper error handling
5. Add documentation and comments
6. Performance testing and optimization

### **Code Review Checklist**
- [ ] TypeScript compilation passes
- [ ] All tests pass
- [ ] ESLint/Prettier formatting
- [ ] Performance considerations addressed
- [ ] Security implications reviewed
- [ ] Accessibility standards met
- [ ] Documentation updated

---

**Remember**: This is a production-ready, open-source application. Every line of code should reflect enterprise-grade quality and maintainability.